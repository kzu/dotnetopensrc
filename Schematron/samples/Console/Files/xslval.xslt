<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" sch:dummy-for-xmlns="" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:sch="http://www.ascc.net/xml/schematron"><xsl:output method="text" /><xsl:template match="*|@*" mode="schematron-get-full-path"><xsl:apply-templates select="parent::*" mode="schematron-get-full-path" /><xsl:text>/</xsl:text><xsl:if test="count(. | ../@*) = count(../@*)">@</xsl:if><xsl:choose><xsl:when test="not(namespace-uri(.)='') and&#xA;         not(contains(name(.), ':'))"><xsl:variable name="sq">'</xsl:variable><xsl:value-of select="concat('*:', local-name(.),&#xA;            '[namespace-uri(.)=', $sq, namespace-uri(.), $sq, ']')" /></xsl:when><xsl:otherwise><xsl:value-of select="name()" /></xsl:otherwise></xsl:choose><xsl:text>[</xsl:text><xsl:value-of select="1+count(preceding-sibling::*[name()=name(current())])" /><xsl:text>]</xsl:text></xsl:template><xsl:template match="/" mode="generate-id-from-path" /><xsl:template match="text()" mode="generate-id-from-path"><xsl:apply-templates select="parent::*" mode="generate-id-from-path" /><xsl:value-of select="concat('.text-', 1+count(preceding-sibling::text()), '-')" /></xsl:template><xsl:template match="comment()" mode="generate-id-from-path"><xsl:apply-templates select="parent::*" mode="generate-id-from-path" /><xsl:value-of select="concat('.comment-', 1+count(preceding-sibling::comment()), '-')" /></xsl:template><xsl:template match="processing-instruction()" mode="generate-id-from-path"><xsl:apply-templates select="parent::*" mode="generate-id-from-path" /><xsl:value-of select="concat('.processing-instruction-',&#xA;      1+count(preceding-sibling::processing-instruction()), '-')" /></xsl:template><xsl:template match="@*" mode="generate-id-from-path"><xsl:apply-templates select="parent::*" mode="generate-id-from-path" /><xsl:value-of select="concat('.@', name())" /></xsl:template><xsl:template match="*" mode="generate-id-from-path" priority="-0.5"><xsl:apply-templates select="parent::*" mode="generate-id-from-path" /><xsl:text>.</xsl:text><xsl:choose><xsl:when test="count(. | ../namespace::*) = count(../namespace::*)">
<xsl:value-of select="concat('.namespace::-',1+count(namespace::*),'-')" /></xsl:when><xsl:otherwise><xsl:value-of select="concat('.',name(),'-',&#xA;            1+count(preceding-sibling::*[name()=name(current())]),'-')" /></xsl:otherwise></xsl:choose></xsl:template><xsl:template match="/">Schematron 1.5


From pattern "Minimal Schematron": <xsl:apply-templates select="/" mode="M8" />

From pattern "Schematron Elements and Required Attributes": <xsl:apply-templates select="/" mode="M9" />

From pattern "Schematron Attributes": <xsl:apply-templates select="/" mode="M10" /></xsl:template><xsl:template match="/" priority="3999" mode="M8"><xsl:choose><xsl:when test="//sch:schema" /><xsl:otherwise>
     Assertion fails: "A Schematron schema should have a schema element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="count(//sch:schema) &gt; 1">
      Report: "There should only be one schema per document."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:choose><xsl:when test="//sch:schema/sch:pattern " /><xsl:otherwise>
     Assertion fails: "A Schematron schema should have pattern elements inside the schema element"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="//sch:schema/sch:pattern/sch:rule[@context]" /><xsl:otherwise>
     Assertion fails: "A Schematron schema should have rule elements inside the pattern elements. Rule elements should have a context attribute."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="//sch:schema/sch:pattern/sch:rule/sch:assert[@test] &#xA; 			or //sch:schema/sch:pattern/sch:rule/sch:report[@test]" /><xsl:otherwise>
     Assertion fails: "A Schematron schema should have assert or report elements inside the rule elements. Assert and report elements should have a test attribute."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M8" /></xsl:template><xsl:template match="text()" priority="-1" mode="M8"></xsl:template><xsl:template match="sch:assert | sch:report" priority="3997" mode="M9"><xsl:choose><xsl:when test="parent::sch:rule" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element rule."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(text())) &gt; 0" /><xsl:otherwise>
     Assertion fails: "A<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should contain a natural language sentence."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@test)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute test. This should be an XSLT expression."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="@context">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element cannot have a context attribute: that should go on the rule element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:schema" priority="3996" mode="M9"><xsl:choose><xsl:when test="count(sch:*) = count(sch:title|sch:ns|sch:phrase|sch:p|sch:pattern|sch:diagnostics|sch:phase)" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain only the elements title, ns, phrase, p, pattern, diagnostics or phase from the Schematron namespace."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="sch:pattern" /><xsl:otherwise>
     Assertion fails: "A schema element should contain at least one pattern element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="ancestor::sch:*">
      Report: "A Schematron schema should not appear as a child of another Schematron schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@defaultPhase and sch:phase and not(@defaultPhase='#ALL') and not(sch:phase[@id= current()/@defaultPhase])">
      Report: "The value of the defaultPhase attribute must match the id of a phase element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:title" priority="3995" mode="M9"><xsl:choose><xsl:when test="parent::sch:schema" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(preceding-sibling::sch:*) = 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear as the first element from the Schematron namespace in the schema element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:ns" priority="3994" mode="M9"><xsl:choose><xsl:when test="parent::sch:schema" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@prefix)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute prefix."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@uri)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute uri."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(preceding-sibling::sch:*) = count(preceding-sibling::sch:title)" /><xsl:otherwise>
     Assertion fails: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element must come before any other Schematron elements, except the title"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="*">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should be empty."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:phase" priority="3993" mode="M9"><xsl:choose><xsl:when test="parent::sch:schema" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(preceding-sibling::sch:*) = count(preceding-sibling::sch:phase)&#xA;			+ count(preceding-sibling::sch:title) + count(preceding-sibling::sch:ns)&#xA;			+ count(preceding-sibling::sch:p)" /><xsl:otherwise>
     Assertion fails: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>elements must come before any other Schematron elements, except the title, ns and p elements"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:active" priority="3992" mode="M9"><xsl:choose><xsl:when test="parent::sch:phase" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element phase."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@pattern)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:pattern" priority="3991" mode="M9"><xsl:choose><xsl:when test="parent::sch:schema" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(sch:*) = count(sch:rule|sch:p)" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain only rule and p elements from the Schematron namespace."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="sch:rule" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain at least one rule element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@name)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(sch:title) &lt; 2" /><xsl:otherwise>
     Assertion fails: "A Schematron schema cannot have more than one title element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:rule[@abstract='true']" priority="3990" mode="M9"><xsl:choose><xsl:when test="parent::sch:pattern" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(sch:*) = count(sch:assert |sch:report|sch:key|sch:extends ) " /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain only the elements assert, report, key or extends from the Schematron namespace."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="sch:assert | sch:report | sch:extends" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain at least one assert, report or extends elements."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="@test">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element cannot have a test attribute: that should go on a report or assert element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@context">
      Report: "An abstract rule cannot have a context attribute."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:choose><xsl:when test="string-length(normalize-space(@id)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "An rule should have an id attribute."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:rule" priority="3989" mode="M9"><xsl:choose><xsl:when test="parent::sch:pattern" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="count(sch:*) = count(sch:assert |sch:report|sch:key|sch:extends ) " /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain only the elements assert, report, key or extends from the Schematron namespace."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="sch:assert | sch:report | sch:extends" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should contain at least one assert, report or extends elements."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="@test">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element cannot have a test attribute: that should go on a report or assert element."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:choose><xsl:when test="string-length(normalize-space(@context)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "A rule should have a context attribute. This should be an XSLT pattern for selecting nodes to make assertions and reports about. (Abstract rules do not require a context attribute.)"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="not(@abstract) or (@abstract='false')  or (@abstract='true')" /><xsl:otherwise>
     Assertion fails: "In a rule, the abstract attribute is optional, and can have values 'true' or 'false'"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:diagnostics" priority="3988" mode="M9"><xsl:choose><xsl:when test="parent::sch:schema" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear as a child of the schema element"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:if test="following-sibling::sch:*">
      Report: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should be the last element in the schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:diagnostic" priority="3987" mode="M9"><xsl:choose><xsl:when test="parent::sch:diagnostics" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear in the diagnostics section."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@id)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute id."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:key" priority="3986" mode="M9"><xsl:choose><xsl:when test="parent::sch:rule" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear in a rule."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@name)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@path)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute path. This should be an XPath expression."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="*">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should be empty."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:extends" priority="3985" mode="M9"><xsl:choose><xsl:when test="parent::sch:rule" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear in a rule."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@rule)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute rule."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="*">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should be empty."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:choose><xsl:when test="/*//sch:rule[@abstract='true'][@id = current()/@rule]" /><xsl:otherwise>
     Assertion fails: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should have an attribute rule which gives the id of an abstract rule."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:p" priority="3984" mode="M9"><xsl:choose><xsl:when test="parent::sch:*" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside an element from the Schematron namespace. It is equivalent to the HTML element of the same name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:name" priority="3983" mode="M9"><xsl:choose><xsl:when test="parent::sch:assert | parent::sch:report |parent::sch:p | parent::sch:diagnostic" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside a Schematron elements p (paragraph) or diagnostic."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:if test="*">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should be empty."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:emph" priority="3982" mode="M9"><xsl:choose><xsl:when test="parent::sch:p | parent::sch:diagnostic" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside a Schematron elements p (paragraph) or diagnostic. It is equivalent to the HTML element of the same name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:dir" priority="3981" mode="M9"><xsl:choose><xsl:when test="parent::sch:p | parent::sch:diagnostic" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside a Schematron elements p (paragraph) or diagnostic."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="@value and (@value='rtl' or @value='ltr')" /><xsl:otherwise>
     Assertion fails: "The attribute value of the<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element must be lowercase "rtl" or "ltr". It is equivalent to the HTML element of the same name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:span" priority="3980" mode="M9"><xsl:choose><xsl:when test="parent::sch:p | parent::sch:diagnostic" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside a Schematron elements p (paragraph) or diagnostic. It is equivalent to the HTML element of the same name."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:value-of" priority="3979" mode="M9"><xsl:choose><xsl:when test="parent::sch:diagnostic" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>should only appear inside the Schematron element diagnostic."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; The element appeared inside a<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(parent::*)" /><xsl:text xml:space="preserve"> </xsl:text>.</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="string-length(normalize-space(@select)) &gt; 0" /><xsl:otherwise>
     Assertion fails: "The element<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>must have a value for the attribute select. The value should be an XPath expression."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:if test="*">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element should be empty."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="sch:*" priority="3978" mode="M9"><xsl:if test="1=1">
      Report: "The<xsl:text xml:space="preserve"> </xsl:text><xsl:value-of select="name(.)" /><xsl:text xml:space="preserve"> </xsl:text>element is not an element from the Schematron 1.5 namespace"  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; Check this is not a spelling error. The recognized element names are schema, title, ns, pattern, rule, key, assert, report, diagnostics, diagnostic, name, value-of, emph and dir.</xsl:if><xsl:apply-templates mode="M9" /></xsl:template><xsl:template match="text()" priority="-1" mode="M9"></xsl:template><xsl:template match="sch:*" priority="3999" mode="M10"><xsl:if test="@abstract and not(self::sch:rule)">
      Report: "The boolean attribute abstract can only appear on the element rule. An abstract rule can be used to extend other rules."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@class and not(self::sch:span or self::sch:p)">
      Report: "The attribute class can only appear on the elements span and p. It gives a name that can be used by CSS stylesheets."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@context and not(self::sch:rule)">
      Report: "The attribute context can only appear on the element rule. It is an XPath pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@defaultPhase and not(self::sch:schema)">
      Report: "The attribute defaultPhase can only appear on the element schema. It is the id of the phase that will initially be active."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@diagnostics and not(self::sch:assert or self::sch:report)">
      Report: "The attribute diagnostics can only appear on the elements assert and report. It is the id of some relevent diagnostic or hint."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@fpi and not(self::sch:schema or self::sch:phase)">
      Report: "The attribute fpi can only appear on the elements schema and phase. It is an ISO Formal Public Identifier."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@icon and not(self::sch:schema or self::sch:assert or&#xA;      			self::sch:diagnostic or self::sch:key or self::sch:p or self::sch:pattern&#xA;      			or self::sch:phase or self::sch:assert )">
      Report: "The attribute icon can only appear on the elements schema, assert , diagnostic, key, p, pattern, phase and report. It is the URL of a small image."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@id and not(self::sch:schema or self::sch:assert or&#xA;     			self::sch:p or self::sch:pattern or self::sch:phase or &#xA;     			self::sch:report or self::sch:rule or self::sch:diagnostic)">
      Report: "The attribute id can only appear on the elements schema, assert, p, pattern, phase, report, rule and diagnostic. It is a name, it should not start with a number or symbol."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@name and not(self::sch:key or self::sch:pattern)">
      Report: "The attribute name can only appear on the elements pattern and key."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@ns and not(self::sch:schema)">
      Report: "The attribute ns can only appear on the schema element. It is the namespace to which the names in the role attributes belong."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@path and not(self::sch:key | self::sch:name)">
      Report: "The attribute path can only appear on the element key. It is an XPath path."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@pattern and not(self::sch:active)">
      Report: "The attribute pattern can only appear on the element active. It gives the id of a pattern that should be activated in that phase."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@prefix and not(self::sch:ns)">
      Report: "The attribute prefix can only appear on the element ns."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@role and not(self::sch:assert or self::sch:report or self::sch:rule)">
      Report: "The attribute role can only appear on the element assert, report or rule. It is a simple name, not a phrase."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@rule and not(self::sch:extends)">
      Report: "The attribute rule can only appear on the element extends. It is the id of an abstract rule declared elsewhere in the schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@see and not(self::sch:pattern)">
      Report: "The attribute see can only appear on the element pattern. It is the URL of some documentation for the schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@select and not(self::sch:value-of)">
      Report: "The attribute select can only appear on the element value-of, with the same meaning as in XSLT. It is an XSLT pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@schemaVersion and not(self::sch:schema)">
      Report: "The attribute schemaVersion can only appear on the element schema. It gives the version of the schema."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@subject and not(self::sch:assert or self::sch:report)">
      Report: "The attribute subject can only appear on the elements assert and report. It is an XSLT pattern."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@test and not(self::sch:assert or self::sch:report)">
      Report: "The attribute test can only appear on the elements assert and report. It is an XPath expression with the XSLT additional functions."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@uri and not(self::sch:ns)">
      Report: "The attribute uri can only appear on the element ns. It is a URI."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@value and not(self::sch:dir)">
      Report: "The attribute value can only appear on the element dir. It sets the directionality of text: 'rtl' is right-to-left and 'ltr' is left-to-right."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:if test="@version and not(self::sch:schema)">
      Report: "The attribute version can only appear on the element schema. It gives the version of Schematron required as major number "." minor number."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:if><xsl:choose><xsl:when test="not(attribute::*) or attribute::*[string-length(normalize-space(text()))=0]" /><xsl:otherwise>
     Assertion fails: "Every attribute on a Schematron element must have a value if it is specified."  at 
         <xsl:apply-templates mode="schematron-get-full-path" select="." /> 
        &lt;<xsl:value-of select="name()" /><xsl:for-each select="@*"><xsl:value-of select="' '" /><xsl:value-of select="name()" />="<xsl:value-of select="." />"</xsl:for-each>&gt;...&lt;/&gt; </xsl:otherwise></xsl:choose><xsl:apply-templates mode="M10" /></xsl:template><xsl:template match="text()" priority="-1" mode="M10"></xsl:template><xsl:template match="text()" priority="-1"></xsl:template></xsl:stylesheet>
